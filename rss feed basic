<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nashville Civic News Aggregator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            color: #333;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        h1 {
            font-size: 28px;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .theme-filter-section {
            margin-bottom: 25px;
            padding: 15px;
            background: #fafafa;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            position: relative;
        }
        
        .theme-processing-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 12px;
            color: #666;
            display: none;
            align-items: center;
            gap: 5px;
        }
        
        .theme-processing-indicator.active {
            display: flex;
        }
        
        .mini-spinner {
            width: 12px;
            height: 12px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #2196F3;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        .theme-filter-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 12px;
            font-weight: 500;
        }
        
        .theme-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .theme-filter-btn {
            padding: 8px 16px;
            border: 2px solid;
            background: white;
            cursor: pointer;
            font-size: 14px;
            border-radius: 20px;
            transition: all 0.3s;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .theme-filter-btn .count {
            background: rgba(0,0,0,0.1);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 12px;
        }
        
        .theme-filter-btn.active {
            color: white;
        }
        
        .theme-filter-btn.active .count {
            background: rgba(255,255,255,0.3);
        }
        
        /* Theme colors */
        .theme-governance { border-color: #4A90E2; color: #4A90E2; }
        .theme-governance.active { background: #4A90E2; }
        
        .theme-transparency { border-color: #7FBA00; color: #7FBA00; }
        .theme-transparency.active { background: #7FBA00; }
        
        .theme-inclusive { border-color: #B854D4; color: #B854D4; }
        .theme-inclusive.active { background: #B854D4; }
        
        .theme-leadership { border-color: #FF8C00; color: #FF8C00; }
        .theme-leadership.active { background: #FF8C00; }
        
        .theme-ritual { border-color: #E81E63; color: #E81E63; }
        .theme-ritual.active { background: #E81E63; }
        
        .theme-power { border-color: #009688; color: #009688; }
        .theme-power.active { background: #009688; }
        
        .theme-care { border-color: #8BC34A; color: #8BC34A; }
        .theme-care.active { background: #8BC34A; }
        
        .theme-all { border-color: #666; color: #666; }
        .theme-all.active { background: #666; }
        
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        button {
            padding: 10px 20px;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
            font-size: 14px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        button:hover:not(:disabled) {
            background: #f0f0f0;
            border-color: #999;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .stats {
            margin-bottom: 20px;
            padding: 15px;
            background: #f9f9f9;
            border-left: 4px solid #2196F3;
            font-size: 14px;
        }
        
        .theme-analytics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #e0e0e0;
        }
        
        .theme-stat {
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .theme-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }
        
        .progress-bar {
            width: 100%;
            height: 24px;
            background: #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 20px;
            position: relative;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: 500;
        }
        
        .loading-indicator {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #2196F3;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .feed-sources {
            margin-bottom: 20px;
            padding: 10px;
            background: #fafafa;
            border-radius: 4px;
            font-size: 12px;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .source-badge {
            display: inline-block;
            padding: 2px 8px;
            margin: 2px;
            background: #e0e0e0;
            border-radius: 12px;
            font-size: 11px;
            transition: all 0.2s;
        }
        
        .source-badge.loading {
            background: #FFC107;
            color: white;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .source-badge.active {
            background: #4CAF50;
            color: white;
        }
        
        .source-badge.error {
            background: #f44336;
            color: white;
        }
        
        .article {
            padding: 20px 0;
            border-bottom: 1px solid #e0e0e0;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .article:last-child {
            border-bottom: none;
        }
        
        .article-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 15px;
            margin-bottom: 8px;
        }
        
        .article-title {
            font-size: 20px;
            line-height: 1.3;
            flex: 1;
        }
        
        .article-title a {
            color: #1976D2;
            text-decoration: none;
        }
        
        .article-title a:hover {
            text-decoration: underline;
        }
        
        .article-themes {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        
        .theme-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
            color: white;
            white-space: nowrap;
        }
        
        .theme-badge.primary {
            opacity: 1;
        }
        
        .theme-badge.secondary {
            opacity: 0.7;
        }
        
        .article-meta {
            font-size: 13px;
            color: #666;
            margin-bottom: 10px;
        }
        
        .article-source {
            color: #f57c00;
            font-weight: 500;
        }
        
        .article-description {
            font-size: 15px;
            color: #555;
            line-height: 1.5;
        }
        
        .article-relevance {
            margin-top: 8px;
            font-size: 11px;
            color: #999;
        }
        
        .error {
            padding: 15px;
            background: #ffebee;
            border-left: 4px solid #f44336;
            color: #c62828;
            margin: 20px 0;
        }
        
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 30px 0;
            padding: 20px 0;
            border-top: 1px solid #e0e0e0;
        }
        
        .pagination button {
            min-width: 40px;
            padding: 8px 12px;
        }
        
        .pagination .page-info {
            margin: 0 20px;
            font-size: 14px;
            color: #666;
        }
        
        .pagination .page-size-selector {
            margin-left: 20px;
        }
        
        .pagination select {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .debug-panel {
            display: none;
            margin: 20px 0;
            padding: 15px;
            background: #263238;
            color: #aed581;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border-radius: 4px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        
        .debug-panel.active {
            display: block;
        }
        
        .filter-section {
            margin-bottom: 20px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 4px;
        }
        
        .filter-label {
            font-size: 14px;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .filter-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .load-settings {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .load-settings label {
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .load-settings input[type="number"] {
            width: 60px;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .load-settings select {
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Nashville Civic News Aggregator</h1>
        
        <div class="theme-filter-section">
            <div class="theme-filter-label">Filter by civic theme:</div>
            <div class="theme-processing-indicator" id="themeProcessing">
                <div class="mini-spinner"></div>
                <span>Analyzing themes...</span>
            </div>
            <div class="theme-filters" id="themeFilters">
                <button class="theme-filter-btn theme-all active" onclick="filterByTheme('all')">
                    All Themes <span class="count">0</span>
                </button>
                <button class="theme-filter-btn theme-governance" onclick="filterByTheme('governance')">
                    Collaborative Governance <span class="count">0</span>
                </button>
                <button class="theme-filter-btn theme-transparency" onclick="filterByTheme('transparency')">
                    Civic Transparency <span class="count">0</span>
                </button>
                <button class="theme-filter-btn theme-inclusive" onclick="filterByTheme('inclusive')">
                    Inclusive Solutions <span class="count">0</span>
                </button>
                <button class="theme-filter-btn theme-leadership" onclick="filterByTheme('leadership')">
                    Contextual Leadership <span class="count">0</span>
                </button>
                <button class="theme-filter-btn theme-ritual" onclick="filterByTheme('ritual')">
                    Culture <span class="count">0</span>
                </button>
                <button class="theme-filter-btn theme-power" onclick="filterByTheme('power')">
                    Power & Resources <span class="count">0</span>
                </button>
                <button class="theme-filter-btn theme-care" onclick="filterByTheme('care')">
                    Systemic Care <span class="count">0</span>
                </button>
            </div>
        </div>
        
        <div class="controls">
            <button onclick="startIterativeLoad()" id="loadBtn">Start Loading Feeds</button>
            <button onclick="stopLoading()" id="stopBtn" disabled>Stop Loading</button>
            <button onclick="clearArticles()">Clear Articles</button>
            <button onclick="toggleDebug()">Toggle Debug</button>
            
            <div class="load-settings">
                <label>
                    <input type="checkbox" id="autoScroll" checked>
                    Auto-scroll
                </label>
                <label>
                    <input type="checkbox" id="liveMode" checked>
                    Live mode
                </label>
                <label>
                    Speed:
                    <select id="loadSpeed">
                        <option value="0" selected>Fast (no delay)</option>
                        <option value="100">Normal</option>
                        <option value="500">Slow</option>
                    </select>
                </label>
            </div>
        </div>
        
        <div class="filter-section">
            <div class="filter-label">Search articles:</div>
            <input type="text" class="filter-input" id="searchInput" placeholder="Filter by title, source, or content..." onkeyup="filterArticles()">
        </div>
        
        <div class="progress-bar" id="progressBar" style="display: none;">
            <div class="progress-fill" id="progressFill" style="width: 0%">0%</div>
        </div>
        
        <div class="debug-panel" id="debugPanel"></div>
        
        <div class="stats" id="stats">
            Ready to load feeds. Click "Start Loading Feeds" to begin.
            <div class="theme-analytics" id="themeAnalytics"></div>
        </div>
        
        <div class="feed-sources" id="feedSources">
            <strong>Feed Sources:</strong> Not loaded yet
        </div>
        
        <div class="pagination" id="topPagination" style="display: none;">
            <button onclick="goToPage(1)">First</button>
            <button onclick="previousPage()">Previous</button>
            <span class="page-info">Page <span id="currentPageTop">1</span> of <span id="totalPagesTop">1</span></span>
            <button onclick="nextPage()">Next</button>
            <button onclick="goToPage(totalPages)">Last</button>
            <div class="page-size-selector">
                Show:
                <select id="pageSizeTop" onchange="changePageSize(this.value)">
                    <option value="10">10</option>
                    <option value="25" selected>25</option>
                    <option value="50">50</option>
                    <option value="100">100</option>
                </select>
            </div>
        </div>
        
        <div id="articlesContainer">
            <div class="loading-indicator">
                <div>Click "Start Loading Feeds" to begin fetching articles</div>
            </div>
        </div>
        
        <div class="pagination" id="bottomPagination" style="display: none;">
            <button onclick="goToPage(1)">First</button>
            <button onclick="previousPage()">Previous</button>
            <span class="page-info">Page <span id="currentPageBottom">1</span> of <span id="totalPagesBottom">1</span></span>
            <button onclick="nextPage()">Next</button>
            <button onclick="goToPage(totalPages)">Last</button>
            <div class="page-size-selector">
                Show:
                <select id="pageSizeBottom" onchange="changePageSize(this.value)">
                    <option value="10">10</option>
                    <option value="25" selected>25</option>
                    <option value="50">50</option>
                    <option value="100">100</option>
                </select>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const SOURCES_API = 'https://xvkq-pq7i-idtl.n7d.xano.io/api:Hj4C6PGO/rss_feed';
        const CORS_PROXY = 'https://api.allorigins.win/raw?url=';
        const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes
        
        // Theme definitions with keywords and weights
        const THEMES = {
            governance: {
                name: 'Collaborative Governance',
                color: '#4A90E2',
                primary: ['governance', 'democracy', 'participation', 'collaboration', 'civic', 'council', 'commission', 'board', 'committee', 'referendum', 'vote', 'voting', 'election'],
                secondary: ['public', 'community', 'citizen', 'resident', 'constituent', 'municipal', 'city', 'county', 'government', 'policy', 'ordinance', 'resolution'],
                phrases: ['public comment', 'town hall', 'community meeting', 'civic engagement', 'public input', 'citizen advisory', 'participatory budgeting'],
                negative: ['sports', 'entertainment', 'game']
            },
            transparency: {
                name: 'Civic Transparency',
                color: '#7FBA00',
                primary: ['transparency', 'accountability', 'disclosure', 'audit', 'investigation', 'report', 'data', 'budget', 'finance', 'spending', 'contract', 'ethics'],
                secondary: ['open', 'public', 'record', 'document', 'information', 'review', 'oversight', 'inspection', 'compliance', 'violation'],
                phrases: ['public records', 'open data', 'financial disclosure', 'freedom of information', 'sunshine law', 'open meeting'],
                negative: ['sports', 'weather']
            },
            inclusive: {
                name: 'Inclusive Solutions',
                color: '#B854D4',
                primary: ['inclusive', 'inclusion', 'diversity', 'equity', 'justice', 'equality', 'discrimination', 'bias', 'barrier', 'access', 'disability', 'immigrant'],
                secondary: ['community', 'minority', 'underserved', 'marginalized', 'vulnerable', 'disparity', 'gap', 'representation', 'voice', 'participation'],
                phrases: ['social justice', 'equal opportunity', 'civil rights', 'fair housing', 'language access', 'cultural competency'],
                negative: ['exclusive event', 'luxury', 'premium']
            },
            leadership: {
                name: 'Contextual Leadership',
                color: '#FF8C00',
                primary: ['leadership', 'leader', 'director', 'chief', 'mayor', 'commissioner', 'administrator', 'manager', 'executive', 'superintendent'],
                secondary: ['appoint', 'hire', 'resign', 'retire', 'candidate', 'nomination', 'selection', 'governance', 'administration', 'management'],
                phrases: ['new leadership', 'leadership change', 'executive search', 'leadership development', 'succession planning'],
                negative: ['sports coach', 'team captain']
            },
            ritual: {
                name: 'Culture',
                color: '#E81E63',
                primary: ['tradition', 'heritage', 'culture', 'festival', 'celebration', 'ceremony', 'memorial', 'commemoration', 'anniversary', 'historic', 'landmark'],
                secondary: ['community', 'gathering', 'event', 'parade', 'fair', 'market', 'arts', 'music', 'theater', 'museum', 'library'],
                phrases: ['cultural event', 'community celebration', 'historic preservation', 'cultural heritage', 'public art', 'community tradition'],
                negative: ['commercial', 'sale', 'discount']
            },
            power: {
                name: 'Power & Resources',
                color: '#009688',
                primary: ['power', 'resource', 'funding', 'grant', 'budget', 'allocation', 'investment', 'development', 'infrastructure', 'utility', 'service'],
                secondary: ['economic', 'financial', 'revenue', 'tax', 'fee', 'cost', 'expense', 'project', 'contract', 'procurement', 'bid'],
                phrases: ['resource allocation', 'budget priority', 'economic development', 'public investment', 'capital improvement', 'tax revenue'],
                negative: ['personal finance', 'stock market']
            },
            care: {
                name: 'Systemic Care',
                color: '#8BC34A',
                primary: ['environment', 'climate', 'sustainability', 'green', 'clean', 'pollution', 'health', 'safety', 'welfare', 'housing', 'homeless', 'food'],
                secondary: ['park', 'tree', 'water', 'air', 'waste', 'recycle', 'energy', 'solar', 'renewable', 'conservation', 'protection', 'preserve'],
                phrases: ['climate action', 'environmental justice', 'public health', 'affordable housing', 'food security', 'community wellness'],
                negative: ['real estate', 'luxury', 'profit']
            }
        };
        
        // State
        let allArticles = [];
        let filteredArticles = [];
        let feedSources = [];
        let debugMode = false;
        let cache = {};
        let isLoading = false;
        let activeThemeFilter = 'all';
        let themeCounts = {};
        
        // Pagination state
        let currentPage = 1;
        let pageSize = 25;
        let totalPages = 1;
        
        // Calculate theme relevance for an article
        function calculateThemeRelevance(article) {
            const text = `${article.title} ${article.description}`.toLowerCase();
            const titleText = article.title.toLowerCase();
            const scores = {};
            
            for (const [themeKey, theme] of Object.entries(THEMES)) {
                let score = 0;
                
                // Check primary keywords (3x weight in title, 1x in description)
                theme.primary.forEach(keyword => {
                    const keywordLower = keyword.toLowerCase();
                    if (titleText.includes(keywordLower)) score += 3;
                    if (text.includes(keywordLower)) score += 1;
                });
                
                // Check secondary keywords (1.5x weight in title, 0.5x in description)
                theme.secondary.forEach(keyword => {
                    const keywordLower = keyword.toLowerCase();
                    if (titleText.includes(keywordLower)) score += 1.5;
                    if (text.includes(keywordLower)) score += 0.5;
                });
                
                // Check phrases (2x weight)
                theme.phrases.forEach(phrase => {
                    const phraseLower = phrase.toLowerCase();
                    if (text.includes(phraseLower)) score += 2;
                });
                
                // Apply negative keywords (reduce score)
                if (theme.negative) {
                    theme.negative.forEach(keyword => {
                        const keywordLower = keyword.toLowerCase();
                        if (text.includes(keywordLower)) score -= 2;
                    });
                }
                
                // Source-based hints
                if (article.source) {
                    const sourceLower = article.source.toLowerCase();
                    if (themeKey === 'care' && sourceLower.includes('environment')) score += 2;
                    if (themeKey === 'governance' && (sourceLower.includes('council') || sourceLower.includes('government'))) score += 2;
                }
                
                scores[themeKey] = Math.max(0, score);
            }
            
            // Determine primary and secondary themes
            const sortedThemes = Object.entries(scores)
                .filter(([_, score]) => score > 0)
                .sort((a, b) => b[1] - a[1]);
            
            const themes = {
                primary: sortedThemes[0] ? sortedThemes[0][0] : null,
                secondary: sortedThemes.slice(1, 3).map(([key]) => key),
                scores: scores
            };
            
            return themes;
        }
        
        // Filter articles by theme
        function filterByTheme(theme) {
            activeThemeFilter = theme;
            
            // Update button states
            document.querySelectorAll('.theme-filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const activeBtn = document.querySelector(`.theme-filter-btn.theme-${theme}`);
            if (activeBtn) activeBtn.classList.add('active');
            
            // Apply filter
            if (theme === 'all') {
                filteredArticles = [];
                currentPage = 1;
                displayArticles(allArticles);
            } else {
                filteredArticles = allArticles.filter(article => {
                    return article.themes && 
                           (article.themes.primary === theme || 
                            (article.themes.secondary && article.themes.secondary.includes(theme)));
                });
                currentPage = 1;
                displayArticles(filteredArticles);
            }
            
            updateStats();
        }
        
        // Update theme counts
        function updateThemeCounts() {
            themeCounts = {
                all: allArticles.length,
                governance: 0,
                transparency: 0,
                inclusive: 0,
                leadership: 0,
                ritual: 0,
                power: 0,
                care: 0
            };
            
            allArticles.forEach(article => {
                if (article.themes) {
                    if (article.themes.primary) {
                        themeCounts[article.themes.primary]++;
                    }
                    if (article.themes.secondary) {
                        article.themes.secondary.forEach(theme => {
                            themeCounts[theme]++;
                        });
                    }
                }
            });
            
            // Update UI counts
            Object.entries(themeCounts).forEach(([theme, count]) => {
                const btn = document.querySelector(`.theme-filter-btn.theme-${theme} .count`);
                if (btn) btn.textContent = count;
            });
            
            // Update analytics
            updateThemeAnalytics();
        }
        
        // Update theme analytics display
        function updateThemeAnalytics() {
            const container = document.getElementById('themeAnalytics');
            let html = '';
            
            Object.entries(THEMES).forEach(([key, theme]) => {
                const count = themeCounts[key] || 0;
                const percentage = allArticles.length > 0 ? 
                    Math.round((count / allArticles.length) * 100) : 0;
                
                html += `
                    <div class="theme-stat">
                        <span class="theme-dot" style="background: ${theme.color}"></span>
                        ${theme.name}: ${count} (${percentage}%)
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        // Simple fuzzy string matching
        function similarity(s1, s2) {
            s1 = s1.toLowerCase();
            s2 = s2.toLowerCase();
            
            if (s1 === s2) return 1.0;
            if (s1.length < 2 || s2.length < 2) return 0.0;
            
            let matches = 0;
            const range = Math.floor(Math.max(s1.length, s2.length) / 2) - 1;
            
            for (let i = 0; i < s1.length; i++) {
                const start = Math.max(0, i - range);
                const end = Math.min(i + range + 1, s2.length);
                
                for (let j = start; j < end; j++) {
                    if (s1[i] === s2[j]) {
                        matches++;
                        break;
                    }
                }
            }
            
            return matches / Math.max(s1.length, s2.length);
        }
        
        // Fuzzy field matching
        function findBestFieldMatch(obj, targetFields, threshold = 0.6) {
            if (!obj || typeof obj !== 'object') return null;
            
            const objKeys = Object.keys(obj);
            let bestMatch = null;
            let bestScore = 0;
            
            for (const target of targetFields) {
                for (const key of objKeys) {
                    const score = similarity(key, target);
                    if (score > bestScore && score >= threshold) {
                        bestScore = score;
                        bestMatch = obj[key];
                    }
                }
            }
            
            return bestMatch;
        }
        
        // Smart field extraction with fuzzy matching
        function extractField(item, fieldType) {
            const fieldMappings = {
                title: ['title', 'headline', 'name', 'subject', 'heading'],
                link: ['link', 'url', 'guid', 'id', 'permalink', 'href'],
                description: ['description', 'summary', 'content', 'excerpt', 'abstract', 'contentsnippet', 'content:encoded'],
                date: ['pubdate', 'published', 'date', 'updated', 'created', 'modified', 'publishedat', 'isodate'],
                author: ['author', 'creator', 'dc:creator', 'contributor', 'by'],
                category: ['category', 'categories', 'tags', 'tag', 'subject', 'topics']
            };
            
            const result = findBestFieldMatch(item, fieldMappings[fieldType]);
            
            if (!result && item) {
                if (fieldType === 'description' && item['content:encoded']) {
                    return item['content:encoded'];
                }
                if (fieldType === 'link' && item.link && typeof item.link === 'object') {
                    return item.link.href || item.link.url || item.link.$;
                }
            }
            
            return result || '';
        }
        
        // Parse RSS/Atom feeds
        function parseRSSFeed(xmlText, sourceName) {
            const parser = new DOMParser();
            const xml = parser.parseFromString(xmlText, 'text/xml');
            const articles = [];
            
            if (xml.querySelector('parsererror')) {
                console.error('XML parse error for', sourceName);
                return articles;
            }
            
            let items = xml.querySelectorAll('item');
            if (items.length === 0) {
                items = xml.querySelectorAll('entry');
            }
            
            items.forEach(item => {
                const itemObj = {};
                for (const child of item.children) {
                    const tagName = child.tagName.toLowerCase();
                    itemObj[tagName] = child.textContent || child.innerHTML;
                    
                    if (child.attributes.length > 0) {
                        for (const attr of child.attributes) {
                            itemObj[`${tagName}_${attr.name}`] = attr.value;
                        }
                    }
                }
                
                const title = extractField(itemObj, 'title');
                const link = extractField(itemObj, 'link');
                const description = extractField(itemObj, 'description');
                const dateStr = extractField(itemObj, 'date');
                const author = extractField(itemObj, 'author');
                const category = extractField(itemObj, 'category');
                
                if (title || description) {
                    const article = {
                        title: cleanText(title || 'Untitled'),
                        link: link || '#',
                        description: cleanHTML(description || ''),
                        date: parseDate(dateStr),
                        author: cleanText(author),
                        category: cleanText(category),
                        source: sourceName,
                        themes: null // Will be calculated later
                    };
                    
                    articles.push(article);
                }
            });
            
            return articles;
        }
        
        // Clean text content
        function cleanText(text) {
            if (!text) return '';
            return text.replace(/<[^>]*>/g, '').trim();
        }
        
        // Clean HTML content
        function cleanHTML(html) {
            if (!html) return '';
            html = html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
            html = html.replace(/<style\b[^<]*(?:(?!<\/style>)<[^<]*)*<\/style>/gi, '');
            html = html.replace(/<[^>]*>/g, ' ');
            html = html.replace(/\s+/g, ' ').trim();
            return html;
        }
        
        // Parse date strings
        function parseDate(dateStr) {
            if (!dateStr) return null;
            const date = new Date(dateStr);
            return isNaN(date.getTime()) ? null : date;
        }
        
        // Load RSS sources from API
        async function loadSources() {
            try {
                const response = await fetch(SOURCES_API);
                if (!response.ok) throw new Error('Failed to load sources');
                
                const data = await response.json();
                feedSources = data;
                updateSourcesDisplay();
                return data;
            } catch (error) {
                console.error('Error loading sources:', error);
                showError('Failed to load feed sources');
                return [];
            }
        }
        
        // Fetch RSS feed content
        async function fetchFeed(source) {
            const url = source.url || source.link;
            const name = source.name || source.title || 'Unknown';
            
            if (!url) return [];
            
            const cacheKey = url;
            const cached = cache[cacheKey];
            if (cached && (Date.now() - cached.timestamp < CACHE_DURATION)) {
                return cached.articles;
            }
            
            try {
                const proxyUrl = CORS_PROXY + encodeURIComponent(url);
                const response = await fetch(proxyUrl);
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const text = await response.text();
                const articles = parseRSSFeed(text, name);
                
                cache[cacheKey] = {
                    articles: articles,
                    timestamp: Date.now()
                };
                
                return articles;
            } catch (error) {
                console.error(`Error fetching ${name}:`, error);
                return [];
            }
        }
        
        // Process themes for articles in background - OPTIMIZED FOR SPEED
        async function processThemesIteratively() {
            const progressBar = document.getElementById('progressBar');
            const themeIndicator = document.getElementById('themeProcessing');
            const articlesToProcess = allArticles.filter(a => a.themes === null);
            
            if (articlesToProcess.length === 0) return;
            
            // Show theme processing indicators
            progressBar.style.display = 'block';
            themeIndicator.classList.add('active');
            updateProgress(0, 'Analyzing themes...');
            
            const batchSize = 25; // Increased batch size for faster processing
            let processed = 0;
            
            // Process all articles as quickly as possible
            for (let i = 0; i < articlesToProcess.length; i += batchSize) {
                const batch = articlesToProcess.slice(i, Math.min(i + batchSize, articlesToProcess.length));
                
                // Process batch immediately without animation frame
                batch.forEach(article => {
                    article.themes = calculateThemeRelevance(article);
                    processed++;
                });
                
                // Update progress less frequently for speed
                if (processed % 50 === 0 || processed === articlesToProcess.length) {
                    const progress = Math.round((processed / articlesToProcess.length) * 100);
                    updateProgress(progress, `Analyzing themes: ${processed} of ${articlesToProcess.length} articles`);
                    
                    // Update theme counts
                    updateThemeCounts();
                    
                    // Update display only every 50 articles for performance
                    const articlesToShow = filteredArticles.length > 0 || activeThemeFilter !== 'all' ? 
                        filteredArticles : allArticles;
                    displayArticles(articlesToShow);
                }
                
                // Minimal delay only if not finished
                if (i + batchSize < articlesToProcess.length) {
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
            }
            
            // Final update
            updateProgress(100, 'Theme analysis complete!');
            updateThemeCounts();
            const articlesToShow = filteredArticles.length > 0 || activeThemeFilter !== 'all' ? 
                filteredArticles : allArticles;
            displayArticles(articlesToShow);
            updateStats();
            
            // Hide indicators
            setTimeout(() => {
                progressBar.style.display = 'none';
                themeIndicator.classList.remove('active');
            }, 1000);
        }
        
        // Start iterative loading
        async function startIterativeLoad() {
            if (isLoading) return;
            
            isLoading = true;
            const loadBtn = document.getElementById('loadBtn');
            const stopBtn = document.getElementById('stopBtn');
            const progressBar = document.getElementById('progressBar');
            const container = document.getElementById('articlesContainer');
            
            loadBtn.disabled = true;
            stopBtn.disabled = false;
            progressBar.style.display = 'block';
            
            // Show immediate feedback
            container.innerHTML = '<div class="loading-indicator"><div class="spinner"></div><div>Starting to load feeds...</div></div>';
            updateProgress(0, 'Loading sources...');
            
            const liveMode = document.getElementById('liveMode').checked;
            if (!liveMode) {
                allArticles = [];
                filteredArticles = [];
                currentPage = 1;
            }
            
            updateStats('Loading feed sources...');
            const sources = await loadSources();
            
            if (sources.length === 0) {
                isLoading = false;
                loadBtn.disabled = false;
                stopBtn.disabled = true;
                progressBar.style.display = 'none';
                container.innerHTML = '<div class="error">No feed sources found</div>';
                return;
            }
            
            // Clear loading indicator once we start getting articles
            let firstArticlesLoaded = false;
            const autoScroll = document.getElementById('autoScroll').checked;
            let loadedCount = 0;
            
            // Load first 5 feeds in parallel for faster initial content
            const initialBatchSize = Math.min(5, sources.length);
            const initialBatch = sources.slice(0, initialBatchSize);
            const remainingSources = sources.slice(initialBatchSize);
            
            // Start first batch in parallel
            updateProgress(0, `Loading initial feeds...`);
            const initialPromises = initialBatch.map(async (source, index) => {
                updateSourceStatus(source.name || source.title, 'loading');
                try {
                    const articles = await fetchFeed(source);
                    return { source, articles, index };
                } catch (error) {
                    console.error(`Error loading ${source.name}:`, error);
                    return { source, articles: [], index };
                }
            });
            
            // Process initial batch results as they come in
            const initialResults = await Promise.all(initialPromises);
            
            for (const result of initialResults) {
                if (!isLoading) break;
                
                loadedCount++;
                
                if (result.articles.length > 0) {
                    if (!firstArticlesLoaded) {
                        firstArticlesLoaded = true;
                        container.innerHTML = '';
                    }
                    
                    updateSourceStatus(result.source.name || result.source.title, 'active');
                    allArticles = allArticles.concat(result.articles);
                } else {
                    updateSourceStatus(result.source.name || result.source.title, 'error');
                }
            }
            
            // Sort once after initial batch
            allArticles.sort((a, b) => {
                if (!a.date) return 1;
                if (!b.date) return -1;
                return b.date - a.date;
            });
            
            // Display initial articles
            filterArticles();
            updateStats(`Loaded ${loadedCount}/${sources.length} feeds | ${allArticles.length} total articles`);
            
            if (autoScroll && firstArticlesLoaded) {
                document.getElementById('articlesContainer').scrollIntoView({ behavior: 'smooth' });
            }
            
            // Start processing themes immediately for initial articles
            if (allArticles.length > 0) {
                processThemesIteratively();
            }
            
            // Process remaining feeds
            for (let i = 0; i < remainingSources.length; i++) {
                if (!isLoading) break;
                
                const source = remainingSources[i];
                const totalIndex = i + initialBatchSize;
                const progress = Math.round((totalIndex / sources.length) * 100);
                
                updateProgress(progress, `Loading feed ${totalIndex + 1} of ${sources.length}: ${source.name || 'Unknown'}`);
                updateSourceStatus(source.name || source.title, 'loading');
                
                // Fetch single feed
                try {
                    const articles = await fetchFeed(source);
                    loadedCount++;
                    
                    if (articles.length > 0) {
                        if (!firstArticlesLoaded) {
                            firstArticlesLoaded = true;
                            container.innerHTML = '';
                        }
                        
                        updateSourceStatus(source.name || source.title, 'active');
                        
                        // Add new articles and process themes immediately
                        const newArticlesStartIndex = allArticles.length;
                        allArticles = allArticles.concat(articles);
                        
                        // Calculate themes for new articles right away
                        for (let j = newArticlesStartIndex; j < allArticles.length; j++) {
                            allArticles[j].themes = calculateThemeRelevance(allArticles[j]);
                        }
                        
                        // Sort all articles by date
                        allArticles.sort((a, b) => {
                            if (!a.date) return 1;
                            if (!b.date) return -1;
                            return b.date - a.date;
                        });
                        
                        // Update counts and display
                        updateThemeCounts();
                        filterArticles();
                    } else {
                        updateSourceStatus(source.name || source.title, 'error');
                    }
                    
                    updateStats(`Loaded ${loadedCount}/${sources.length} feeds | ${allArticles.length} total articles`);
                    
                } catch (error) {
                    console.error(`Error loading ${source.name}:`, error);
                    updateSourceStatus(source.name || source.title, 'error');
                }
                
                // Only delay if speed is not set to fast
                const loadSpeed = parseInt(document.getElementById('loadSpeed').value) || 0;
                if (i < remainingSources.length - 1 && isLoading && loadSpeed > 0) {
                    await new Promise(resolve => setTimeout(resolve, loadSpeed));
                }
            }
            
            // If no articles were loaded at all
            if (!firstArticlesLoaded) {
                container.innerHTML = '<div class="error">No articles found in any feeds</div>';
            }
            
            updateProgress(100, 'Loading complete!');
            updateStats(`Loaded all ${sources.length} feeds | ${allArticles.length} total articles`);
            
            setTimeout(() => {
                progressBar.style.display = 'none';
            }, 2000);
            
            isLoading = false;
            loadBtn.disabled = false;
            stopBtn.disabled = true;
            
            if (debugMode) {
                updateDebug();
            }
        }
        
        // Stop loading
        function stopLoading() {
            isLoading = false;
            const loadBtn = document.getElementById('loadBtn');
            const stopBtn = document.getElementById('stopBtn');
            const progressBar = document.getElementById('progressBar');
            
            loadBtn.disabled = false;
            stopBtn.disabled = true;
            
            updateStats('Loading stopped by user');
            updateProgress(0, 'Stopped');
            
            setTimeout(() => {
                progressBar.style.display = 'none';
            }, 1000);
        }
        
        // Clear articles
        function clearArticles() {
            allArticles = [];
            filteredArticles = [];
            currentPage = 1;
            cache = {};
            activeThemeFilter = 'all';
            
            displayArticles([]);
            updateThemeCounts();
            updateStats('Articles cleared. Cache reset.');
            
            feedSources.forEach(source => {
                updateSourceStatus(source.name || source.title, '');
            });
            
            document.querySelectorAll('.theme-filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector('.theme-filter-btn.theme-all').classList.add('active');
        }
        
        // Update progress bar
        function updateProgress(percent, text) {
            const fill = document.getElementById('progressFill');
            fill.style.width = percent + '%';
            fill.textContent = text || percent + '%';
        }
        
        // Display articles with pagination
        function displayArticles(articles) {
            const container = document.getElementById('articlesContainer');
            
            if (!articles || articles.length === 0) {
                container.innerHTML = '<div class="error">No articles found</div>';
                document.getElementById('topPagination').style.display = 'none';
                document.getElementById('bottomPagination').style.display = 'none';
                return;
            }
            
            totalPages = Math.ceil(articles.length / pageSize);
            currentPage = Math.min(currentPage, totalPages);
            
            const startIndex = (currentPage - 1) * pageSize;
            const endIndex = Math.min(startIndex + pageSize, articles.length);
            const pageArticles = articles.slice(startIndex, endIndex);
            
            updatePaginationControls();
            
            let html = '';
            pageArticles.forEach(article => {
                html += '<div class="article">';
                
                // Header with title and theme badges
                html += '<div class="article-header">';
                html += '<div class="article-title">';
                html += `<a href="${escapeHtml(article.link)}" target="_blank" rel="noopener">`;
                html += escapeHtml(article.title);
                html += '</a></div>';
                
                // Theme badges
                if (article.themes && article.themes.primary && (article.themes.primary || article.themes.secondary.length > 0)) {
                    html += '<div class="article-themes">';
                    
                    if (article.themes.primary) {
                        const theme = THEMES[article.themes.primary];
                        html += `<span class="theme-badge primary" style="background: ${theme.color}">${theme.name}</span>`;
                    }
                    
                    if (article.themes.secondary) {
                        article.themes.secondary.forEach(themeKey => {
                            const theme = THEMES[themeKey];
                            if (theme) {
                                html += `<span class="theme-badge secondary" style="background: ${theme.color}">${theme.name}</span>`;
                            }
                        });
                    }
                    
                    html += '</div>';
                }
                
                html += '</div>';
                
                // Meta information
                html += '<div class="article-meta">';
                html += `<span class="article-source">${escapeHtml(article.source)}</span>`;
                if (article.date) {
                    html += `  ${article.date.toLocaleString()}`;
                }
                if (article.author) {
                    html += `  By ${escapeHtml(article.author)}`;
                }
                html += '</div>';
                
                // Description
                if (article.description) {
                    html += '<div class="article-description">';
                    const desc = article.description.substring(0, 300);
                    html += escapeHtml(desc);
                    if (article.description.length > 300) html += '...';
                    html += '</div>';
                }
                
                // Debug: show relevance scores
                if (debugMode && article.themes && article.themes.scores) {
                    html += '<div class="article-relevance">';
                    const relevantScores = Object.entries(article.themes.scores)
                        .filter(([_, score]) => score > 0)
                        .sort((a, b) => b[1] - a[1])
                        .map(([theme, score]) => `${theme}: ${score.toFixed(1)}`)
                        .join(', ');
                    if (relevantScores) {
                        html += `Relevance scores: ${relevantScores}`;
                    }
                    html += '</div>';
                }
                
                html += '</div>';
            });
            
            container.innerHTML = html;
            
            const showPagination = articles.length > pageSize;
            document.getElementById('topPagination').style.display = showPagination ? 'flex' : 'none';
            document.getElementById('bottomPagination').style.display = showPagination ? 'flex' : 'none';
        }
        
        // Update pagination controls
        function updatePaginationControls() {
            document.getElementById('currentPageTop').textContent = currentPage;
            document.getElementById('totalPagesTop').textContent = totalPages;
            document.getElementById('currentPageBottom').textContent = currentPage;
            document.getElementById('totalPagesBottom').textContent = totalPages;
        }
        
        // Pagination functions
        function goToPage(page) {
            currentPage = Math.max(1, Math.min(page, totalPages));
            displayArticles(filteredArticles.length > 0 || activeThemeFilter !== 'all' ? filteredArticles : allArticles);
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        function nextPage() {
            goToPage(currentPage + 1);
        }
        
        function previousPage() {
            goToPage(currentPage - 1);
        }
        
        function changePageSize(size) {
            pageSize = parseInt(size);
            currentPage = 1;
            document.getElementById('pageSizeTop').value = size;
            document.getElementById('pageSizeBottom').value = size;
            displayArticles(filteredArticles.length > 0 || activeThemeFilter !== 'all' ? filteredArticles : allArticles);
        }
        
        // Filter articles by search term
        function filterArticles() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            
            let baseArticles = activeThemeFilter === 'all' ? allArticles : 
                allArticles.filter(article => {
                    return article.themes && 
                           (article.themes.primary === activeThemeFilter || 
                            article.themes.secondary.includes(activeThemeFilter));
                });
            
            if (!searchTerm) {
                filteredArticles = activeThemeFilter === 'all' ? [] : baseArticles;
                displayArticles(baseArticles);
                updateStats();
                return;
            }
            
            filteredArticles = baseArticles.filter(article => {
                return article.title.toLowerCase().includes(searchTerm) ||
                       article.description.toLowerCase().includes(searchTerm) ||
                       article.source.toLowerCase().includes(searchTerm) ||
                       (article.category && article.category.toLowerCase().includes(searchTerm));
            });
            
            currentPage = 1;
            displayArticles(filteredArticles);
            updateStats();
        }
        
        // Update sources display
        function updateSourcesDisplay() {
            const container = document.getElementById('feedSources');
            let html = '<strong>Feed Sources:</strong> ';
            
            feedSources.forEach(source => {
                const name = source.name || source.title || 'Unknown';
                html += `<span class="source-badge" id="source-${name.replace(/\s+/g, '-')}">${escapeHtml(name)}</span>`;
            });
            
            container.innerHTML = html;
        }
        
        // Update source status
        function updateSourceStatus(name, status) {
            const badge = document.getElementById(`source-${name.replace(/\s+/g, '-')}`);
            if (badge) {
                badge.className = `source-badge ${status}`;
            }
        }
        
        // Update stats
        function updateStats(customMessage) {
            const articlesToShow = filteredArticles.length > 0 || activeThemeFilter !== 'all' ? 
                filteredArticles : allArticles;
            
            let message = customMessage || `Showing ${articlesToShow.length} articles`;
            
            if (activeThemeFilter !== 'all') {
                const themeName = THEMES[activeThemeFilter]?.name || activeThemeFilter;
                message += ` (filtered by ${themeName})`;
            }
            
            if (filteredArticles.length > 0 && document.getElementById('searchInput').value) {
                message += ' (search active)';
            }
            
            document.getElementById('stats').innerHTML = message + 
                '<div class="theme-analytics" id="themeAnalytics"></div>';
            
            updateThemeAnalytics();
        }
        
        // Show error
        function showError(message) {
            const container = document.getElementById('articlesContainer');
            container.innerHTML = `<div class="error">${escapeHtml(message)}</div>`;
        }
        
        // Toggle debug panel
        function toggleDebug() {
            debugMode = !debugMode;
            const panel = document.getElementById('debugPanel');
            panel.classList.toggle('active');
            
            if (debugMode) {
                updateDebug();
                // Re-display articles to show relevance scores
                const articlesToShow = filteredArticles.length > 0 || activeThemeFilter !== 'all' ? 
                    filteredArticles : allArticles;
                displayArticles(articlesToShow);
            } else {
                // Re-display without scores
                const articlesToShow = filteredArticles.length > 0 || activeThemeFilter !== 'all' ? 
                    filteredArticles : allArticles;
                displayArticles(articlesToShow);
            }
        }
        
        // Update debug info
        function updateDebug() {
            const panel = document.getElementById('debugPanel');
            let debug = 'Debug Information\n';
            debug += '=================\n\n';
            debug += `Total Sources: ${feedSources.length}\n`;
            debug += `Total Articles: ${allArticles.length}\n`;
            debug += `Filtered Articles: ${filteredArticles.length}\n`;
            debug += `Active Theme Filter: ${activeThemeFilter}\n`;
            debug += `Cache Entries: ${Object.keys(cache).length}\n`;
            debug += `Current Page: ${currentPage}/${totalPages}\n`;
            debug += `Page Size: ${pageSize}\n\n`;
            
            debug += 'Theme Distribution:\n';
            Object.entries(themeCounts).forEach(([theme, count]) => {
                if (theme !== 'all') {
                    const percentage = allArticles.length > 0 ? 
                        Math.round((count / allArticles.length) * 100) : 0;
                    debug += `  ${theme}: ${count} articles (${percentage}%)\n`;
                }
            });
            
            debug += '\nArticles by Source:\n';
            const sourceCounts = {};
            allArticles.forEach(article => {
                sourceCounts[article.source] = (sourceCounts[article.source] || 0) + 1;
            });
            
            Object.entries(sourceCounts)
                .sort((a, b) => b[1] - a[1])
                .forEach(([source, count]) => {
                    debug += `  ${source}: ${count} articles\n`;
                });
            
            if (allArticles.length > 0) {
                debug += '\nMost Recent Article with Themes:\n';
                const recentWithTheme = allArticles.find(a => a.themes && a.themes.primary);
                if (recentWithTheme) {
                    debug += JSON.stringify({
                        title: recentWithTheme.title,
                        themes: recentWithTheme.themes,
                        source: recentWithTheme.source
                    }, null, 2);
                }
            }
            
            panel.textContent = debug;
        }
        
        // Escape HTML
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = String(text);
            return div.innerHTML;
        }
        
        // Auto-refresh timer
        let refreshInterval = null;
        
        function startAutoRefresh() {
            if (refreshInterval) clearInterval(refreshInterval);
            refreshInterval = setInterval(() => {
                if (!isLoading && document.getElementById('liveMode').checked) {
                    startIterativeLoad();
                }
            }, 5 * 60 * 1000); // 5 minutes
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            updateStats('Ready to load feeds. Click "Start Loading Feeds" to begin.');
            startAutoRefresh();
        });
    </script>
</body>
</html>
