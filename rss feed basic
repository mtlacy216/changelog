<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nashville Civic News Aggregator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            color: #333;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        h1 {
            font-size: 28px;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .sync-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 12px;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .sync-status.syncing {
            background: #FFF3CD;
            border: 1px solid #FFC107;
        }
        
        .sync-status.success {
            background: #D4EDDA;
            border: 1px solid #28A745;
        }
        
        .sync-status.error {
            background: #F8D7DA;
            border: 1px solid #DC3545;
        }
        
        .cache-stats {
            background: #E3F2FD;
            border-left: 4px solid #2196F3;
            padding: 10px 15px;
            margin-bottom: 20px;
            font-size: 13px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .cache-stats span {
            margin-right: 15px;
        }
        
        /* New Content Faucet Styles */
        .content-faucet {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            color: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .faucet-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .faucet-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .faucet-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .faucet-toggle.active {
            background: rgba(255, 255, 255, 0.4);
        }
        
        .faucet-icon {
            font-size: 24px;
            transition: transform 0.3s;
        }
        
        .faucet-toggle.active .faucet-icon {
            transform: rotate(90deg);
        }
        
        .faucet-status {
            font-size: 14px;
            font-weight: 500;
        }
        
        .faucet-count {
            background: rgba(255, 255, 255, 0.3);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .new-content-indicator {
            position: fixed;
            top: 80px;
            right: 20px;
            background: #4CAF50;
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
            font-size: 13px;
            z-index: 999;
            display: none;
            animation: slideInRight 0.3s ease;
            cursor: pointer;
        }
        
        .new-content-indicator.active {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .theme-filter-section {
            margin-bottom: 25px;
            padding: 15px;
            background: #fafafa;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            position: relative;
        }
        
        .theme-processing-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 12px;
            color: #666;
            display: none;
            align-items: center;
            gap: 5px;
        }
        
        .theme-processing-indicator.active {
            display: flex;
        }
        
        .mini-spinner {
            width: 12px;
            height: 12px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #2196F3;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        .theme-filter-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 12px;
            font-weight: 500;
        }
        
        .theme-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .theme-filter-btn {
            padding: 8px 16px;
            border: 2px solid;
            background: white;
            cursor: pointer;
            font-size: 14px;
            border-radius: 20px;
            transition: all 0.3s;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .theme-filter-btn .count {
            background: rgba(0,0,0,0.1);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 12px;
        }
        
        .theme-filter-btn.active {
            color: white;
        }
        
        .theme-filter-btn.active .count {
            background: rgba(255,255,255,0.3);
        }
        
        /* Theme colors */
        .theme-governance { border-color: #4A90E2; color: #4A90E2; }
        .theme-governance.active { background: #4A90E2; }
        
        .theme-transparency { border-color: #7FBA00; color: #7FBA00; }
        .theme-transparency.active { background: #7FBA00; }
        
        .theme-decisions { border-color: #B854D4; color: #B854D4; }
        .theme-decisions.active { background: #B854D4; }
        
        .theme-leadership { border-color: #FF8C00; color: #FF8C00; }
        .theme-leadership.active { background: #FF8C00; }
        
        .theme-culture { border-color: #E81E63; color: #E81E63; }
        .theme-culture.active { background: #E81E63; }
        
        .theme-resources { border-color: #009688; color: #009688; }
        .theme-resources.active { background: #009688; }
        
        .theme-care { border-color: #8BC34A; color: #8BC34A; }
        .theme-care.active { background: #8BC34A; }
        
        .theme-all { border-color: #666; color: #666; }
        .theme-all.active { background: #666; }
        
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        button {
            padding: 10px 20px;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
            font-size: 14px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        button:hover:not(:disabled) {
            background: #f0f0f0;
            border-color: #999;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .stats {
            margin-bottom: 20px;
            padding: 15px;
            background: #f9f9f9;
            border-left: 4px solid #2196F3;
            font-size: 14px;
        }
        
        .theme-analytics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #e0e0e0;
        }
        
        .theme-stat {
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .theme-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }
        
        .progress-bar {
            width: 100%;
            height: 24px;
            background: #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 20px;
            position: relative;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: 500;
        }
        
        .loading-indicator {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #2196F3;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .feed-sources {
            margin-bottom: 20px;
            padding: 10px;
            background: #fafafa;
            border-radius: 4px;
            font-size: 12px;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .source-badge {
            display: inline-block;
            padding: 2px 8px;
            margin: 2px;
            background: #e0e0e0;
            border-radius: 12px;
            font-size: 11px;
            transition: all 0.2s;
        }
        
        .source-badge.loading {
            background: #FFC107;
            color: white;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .source-badge.active {
            background: #4CAF50;
            color: white;
        }
        
        .source-badge.error {
            background: #f44336;
            color: white;
        }
        
        .article {
            padding: 20px 0;
            border-bottom: 1px solid #e0e0e0;
            animation: slideIn 0.3s ease;
            position: relative;
        }
        
        .article.new-article {
            background: linear-gradient(90deg, rgba(76, 175, 80, 0.1) 0%, transparent 100%);
            animation: slideInNew 0.5s ease;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes slideInNew {
            from {
                opacity: 0;
                transform: translateX(-20px);
                background: rgba(76, 175, 80, 0.2);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        .article:last-child {
            border-bottom: none;
        }
        
        .article-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 15px;
            margin-bottom: 8px;
        }
        
        .article-title {
            font-size: 20px;
            line-height: 1.3;
            flex: 1;
        }
        
        .article-title a {
            color: #1976D2;
            text-decoration: none;
        }
        
        .article-title a:hover {
            text-decoration: underline;
        }
        
        .article-themes {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        
        .theme-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
            color: white;
            white-space: nowrap;
            position: relative;
        }
        
        .theme-badge.primary {
            opacity: 1;
        }
        
        .theme-badge.secondary {
            opacity: 0.7;
        }
        
        .theme-badge.low-confidence {
            opacity: 0.5;
        }
        
        .confidence-indicator {
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            margin-left: 4px;
            vertical-align: middle;
        }
        
        .confidence-high { background: #4CAF50; }
        .confidence-medium { background: #FFC107; }
        .confidence-low { background: #FF9800; }
        
        .article-meta {
            font-size: 13px;
            color: #666;
            margin-bottom: 10px;
        }
        
        .article-source {
            color: #f57c00;
            font-weight: 500;
        }
        
        .article-description {
            font-size: 15px;
            color: #555;
            line-height: 1.5;
        }
        
        .article-cached {
            display: inline-block;
            margin-left: 10px;
            padding: 2px 6px;
            background: #E3F2FD;
            color: #1976D2;
            border-radius: 4px;
            font-size: 11px;
        }
        
        .article-new {
            display: inline-block;
            margin-left: 10px;
            padding: 2px 6px;
            background: #E8F5E9;
            color: #4CAF50;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }
        
        .error {
            padding: 15px;
            background: #ffebee;
            border-left: 4px solid #f44336;
            color: #c62828;
            margin: 20px 0;
        }
        
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 30px 0;
            padding: 20px 0;
            border-top: 1px solid #e0e0e0;
        }
        
        .pagination button {
            min-width: 40px;
            padding: 8px 12px;
        }
        
        .pagination .page-info {
            margin: 0 20px;
            font-size: 14px;
            color: #666;
        }
        
        .pagination .page-size-selector {
            margin-left: 20px;
        }
        
        .pagination select {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .debug-panel {
            display: none;
            margin: 20px 0;
            padding: 15px;
            background: #263238;
            color: #aed581;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border-radius: 4px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        
        .debug-panel.active {
            display: block;
        }
        
        .filter-section {
            margin-bottom: 20px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 4px;
        }
        
        .filter-label {
            font-size: 14px;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .filter-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .load-settings {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .load-settings label {
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .load-settings input[type="number"] {
            width: 60px;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .theme-legend {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.6;
        }
        
        .theme-legend.active {
            display: block;
        }
        
        .theme-legend h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #333;
        }
        
        .theme-legend-item {
            margin-bottom: 10px;
            padding-left: 20px;
            position: relative;
        }
        
        .theme-legend-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 6px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--theme-color);
        }
        
        .theme-legend-item strong {
            display: inline-block;
            margin-bottom: 2px;
        }
        
        .theme-legend-item small {
            display: block;
            color: #666;
        }
        
        .theme-help-btn {
            display: inline-block;
            margin-left: 10px;
            padding: 2px 8px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 12px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .theme-help-btn:hover {
            background: #e0e0e0;
        }
        
        .load-settings {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .load-settings label {
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .load-settings input[type="number"] {
            width: 60px;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .load-settings select {
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Nashville Civic News Aggregator</h1>
        
        <div class="sync-status" id="syncStatus">
            <span>Ready</span>
        </div>
        
        <div class="new-content-indicator" id="newContentIndicator" onclick="showNewContent()">
            <span>🆕</span>
            <span id="newContentCount">0</span> new articles available
        </div>
        
        <div class="cache-stats" id="cacheStats">
            <div>
                <span>🗄️ Cached: <strong id="cachedCount">0</strong></span>
                <span>🆕 New: <strong id="newCount">0</strong></span>
                <span>📡 From RSS: <strong id="rssCount">0</strong></span>
                <span>🚫 Filtered: <strong id="filteredCount">0</strong></span>
            </div>
            <div>
                <span>Last sync: <strong id="lastSync">Never</strong></span>
            </div>
        </div>
        
        <!-- New Content Faucet -->
        <div class="content-faucet">
            <div class="faucet-info">
                <span class="faucet-icon">💧</span>
                <div>
                    <div class="faucet-status" id="faucetStatus">New Content Stream</div>
                    <div style="font-size: 12px; opacity: 0.9;" id="faucetInfo">Click to turn on/off new articles</div>
                </div>
            </div>
            <div class="faucet-toggle" id="faucetToggle" onclick="toggleContentFaucet()">
                <span id="faucetState">OFF</span>
                <span class="faucet-count" id="pendingCount">0 pending</span>
            </div>
        </div>
        
        <div class="theme-filter-section">
            <div class="theme-filter-label">
                Filter by theme: 
                <span style="font-size: 12px; color: #999; cursor: help;" title="Themes categorize articles based on systemic patterns:
• Governance Models - How groups organize authority
• Transparency Topics - Information flow and openness
• Decision Approaches - Methods for making choices
• Leadership Patterns - How leadership emerges and adapts
• Cultural Dynamics - Rituals and meaning-making
• Resource Distribution - How power and wealth flow
• Care Systems - Structural and planetary-scale care">ⓘ</span>
                <span class="theme-help-btn" onclick="toggleThemeLegend()">Show Guide</span>
            </div>
            <div class="theme-processing-indicator" id="themeProcessing">
                <div class="mini-spinner"></div>
                <span>Analyzing themes...</span>
            </div>
            <div class="theme-filters" id="themeFilters">
                <button class="theme-filter-btn theme-all active" onclick="filterByTheme('all')">
                    All Themes <span class="count">0</span>
                </button>
                <button class="theme-filter-btn theme-governance" onclick="filterByTheme('governance')">
                    Governance Models <span class="count">0</span>
                </button>
                <button class="theme-filter-btn theme-transparency" onclick="filterByTheme('transparency')">
                    Transparency Topics <span class="count">0</span>
                </button>
                <button class="theme-filter-btn theme-decisions" onclick="filterByTheme('decisions')">
                    Decision Approaches <span class="count">0</span>
                </button>
                <button class="theme-filter-btn theme-leadership" onclick="filterByTheme('leadership')">
                    Leadership Patterns <span class="count">0</span>
                </button>
                <button class="theme-filter-btn theme-culture" onclick="filterByTheme('culture')">
                    Cultural Dynamics <span class="count">0</span>
                </button>
                <button class="theme-filter-btn theme-resources" onclick="filterByTheme('resources')">
                    Resource Distribution <span class="count">0</span>
                </button>
                <button class="theme-filter-btn theme-care" onclick="filterByTheme('care')">
                    Care Systems <span class="count">0</span>
                </button>
            </div>
            <div class="theme-legend" id="themeLegend">
                <h4>Theme Classification Guide</h4>
                <div class="theme-legend-item" style="--theme-color: #4A90E2;">
                    <strong style="color: #4A90E2;">Governance Models</strong>
                    <small>How groups organize authority, make collective decisions, and coordinate without coercion. Looks for: "who decides" questions, voting systems, organizational structures.</small>
                </div>
                <div class="theme-legend-item" style="--theme-color: #7FBA00;">
                    <strong style="color: #7FBA00;">Transparency Topics</strong>
                    <small>Information flow, truth-telling, feedback mechanisms, and openness in systems. Looks for: "who knows what" questions, accountability, disclosure, audits.</small>
                </div>
                <div class="theme-legend-item" style="--theme-color: #B854D4;">
                    <strong style="color: #B854D4;">Decision Approaches</strong>
                    <small>Methods for making choices, moving beyond binary either/or thinking. Looks for: trade-offs, deliberation processes, participatory vs delegated decisions.</small>
                </div>
                <div class="theme-legend-item" style="--theme-color: #FF8C00;">
                    <strong style="color: #FF8C00;">Leadership Patterns</strong>
                    <small>How leadership emerges, adapts to context, and circulates rather than remaining fixed. Looks for: "who leads when" questions, contextual authority, expertise.</small>
                </div>
                <div class="theme-legend-item" style="--theme-color: #E81E63;">
                    <strong style="color: #E81E63;">Cultural Dynamics</strong>
                    <small>Rituals, myths, meaning-making, and symbolic practices that bind groups. Looks for: "how we do things" references, traditions, shared values, ceremonies.</small>
                </div>
                <div class="theme-legend-item" style="--theme-color: #009688;">
                    <strong style="color: #009688;">Resource Distribution</strong>
                    <small>How power, wealth, and resources flow, accumulate, or circulate in systems. Looks for: "who has what" questions, economic flows, commons management.</small>
                </div>
                <div class="theme-legend-item" style="--theme-color: #8BC34A;">
                    <strong style="color: #8BC34A;">Care Systems</strong>
                    <small>Structural and planetary-scale care, maintenance, and long-term sustainability. Looks for: collective wellbeing, infrastructure, ecosystem health, resilience.</small>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <button onclick="loadCachedContent()" id="loadCacheBtn">📥 Load Cached</button>
            <button onclick="startRSSFetch()" id="fetchRSSBtn">🔄 Fetch New RSS</button>
            <button onclick="stopFetching()" id="stopBtn" style="display: none; background: #ff4444; color: white;">⏹ Stop</button>
            <button onclick="forceRefresh()" id="refreshBtn">🔃 Force Refresh</button>
            <button onclick="clearArticles()">Clear Articles</button>
            <button onclick="toggleDebug()">Toggle Debug</button>
            
            <div class="load-settings">
                <label>
                    Time window:
                    <select id="timeWindow">
                        <option value="24">24 hours</option>
                        <option value="48" selected>48 hours</option>
                        <option value="72">3 days</option>
                        <option value="168">1 week</option>
                    </select>
                </label>
            </div>
        </div>
        
        <div class="filter-section">
            <div class="filter-label">Search articles:</div>
            <input type="text" class="filter-input" id="searchInput" placeholder="Filter by title, source, or content..." onkeyup="filterArticles()">
        </div>
        
        <div class="progress-bar" id="progressBar" style="display: none;">
            <div class="progress-fill" id="progressFill" style="width: 0%">0%</div>
        </div>
        
        <div class="debug-panel" id="debugPanel"></div>
        
        <div class="stats" id="stats">
            Ready to load. Click "Load Cached" to begin.
            <div class="theme-analytics" id="themeAnalytics"></div>
        </div>
        
        <div class="feed-sources" id="feedSources">
            <strong>Feed Sources:</strong> Not loaded yet
        </div>
        
        <div class="pagination" id="topPagination" style="display: none;">
            <button onclick="goToPage(1)">First</button>
            <button onclick="previousPage()">Previous</button>
            <span class="page-info">Page <span id="currentPageTop">1</span> of <span id="totalPagesTop">1</span></span>
            <button onclick="nextPage()">Next</button>
            <button onclick="goToPage(totalPages)">Last</button>
            <div class="page-size-selector">
                Show:
                <select id="pageSizeTop" onchange="changePageSize(this.value)">
                    <option value="10">10</option>
                    <option value="25" selected>25</option>
                    <option value="50">50</option>
                    <option value="100">100</option>
                </select>
            </div>
        </div>
        
        <div id="articlesContainer">
            <div class="loading-indicator">
                <div>Click "Load Cached" to fetch cached articles</div>
            </div>
        </div>
        
        <div class="pagination" id="bottomPagination" style="display: none;">
            <button onclick="goToPage(1)">First</button>
            <button onclick="previousPage()">Previous</button>
            <span class="page-info">Page <span id="currentPageBottom">1</span> of <span id="totalPagesBottom">1</span></span>
            <button onclick="nextPage()">Next</button>
            <button onclick="goToPage(totalPages)">Last</button>
            <div class="page-size-selector">
                Show:
                <select id="pageSizeBottom" onchange="changePageSize(this.value)">
                    <option value="10">10</option>
                    <option value="25" selected>25</option>
                    <option value="50">50</option>
                    <option value="100">100</option>
                </select>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const XANO_API = 'https://xvkq-pq7i-idtl.n7d.xano.io/api:Hj4C6PGO';
        const SOURCES_API = `${XANO_API}/rss_feed`;
        const CONTENT_API = `${XANO_API}/content`;
        const CORS_PROXY = 'https://api.allorigins.win/raw?url=';
        
        // Cache configuration
        const CACHE_CONFIG = {
            defaultTimeWindow: 48 * 60 * 60 * 1000,  // 48 hours
            batchSize: 20,                            // Articles to POST at once
            localCacheKey: 'nashville_civic_cache'
        };
        
        // Theme definitions with NLP matching patterns
        const THEMES = {
            governance: {
                name: 'Governance Models',
                color: '#4A90E2',
                primary: ['governance', 'authority', 'power-with', 'consent', 'coercion', 'control', 'coordination', 'holacracy', 'sociocracy', 'democracy', 'federalism', 'confederation', 'consensus'],
                secondary: ['legitimacy', 'sovereignty', 'self-organization', 'distributed', 'subsidiary', 'governing', 'ruling', 'managing', 'coordinating', 'organizing', 'administering', 'council', 'commission', 'board'],
                phrases: ['who decides', 'how decisions are made', 'collective action', 'organizational hierarchy', 'decision-making structures', 'voting system', 'consensus process'],
                patterns: ['authority structure', 'power dynamics', 'organizational model'],
                negative: ['sports', 'entertainment', 'game']
            },
            transparency: {
                name: 'Transparency Topics',
                color: '#7FBA00',
                primary: ['transparency', 'truth', 'honesty', 'feedback', 'grievance', 'disclosure', 'openness', 'whistleblowing', 'ombudsman', 'audit', 'reporting', 'accountability'],
                secondary: ['information', 'concealment', 'exposure', 'parrhesia', 'candor', 'revealing', 'hiding', 'sharing', 'exposing', 'monitoring', 'oversight', 'inspection'],
                phrases: ['who knows what', 'information asymmetry', 'feedback loops', 'communication channels', 'open records', 'public disclosure', 'information access'],
                patterns: ['secrecy vs openness', 'information flow', 'accountability mechanisms'],
                negative: ['sports', 'weather']
            },
            decisions: {
                name: 'Decision Approaches',
                color: '#B854D4',
                primary: ['decision', 'choice', 'binary', 'either/or', 'both/and', 'third-way', 'alternatives', 'deliberation', 'voting', 'consultation', 'participation', 'delegation'],
                secondary: ['closure', 'openness', 'speed', 'reflection', 'multi-criteria', 'polarity', 'choosing', 'deciding', 'deliberating', 'consulting', 'weighing', 'options'],
                phrases: ['should we', 'trade-offs', 'dilemmas', 'decision process', 'quick vs reflective', 'participatory decision', 'delegated authority'],
                patterns: ['binary thinking', 'alternative solutions', 'decision timing'],
                negative: ['routine', 'automatic']
            },
            leadership: {
                name: 'Leadership Patterns',
                color: '#FF8C00',
                primary: ['leadership', 'leader', 'authority', 'expertise', 'stewardship', 'guidance', 'rotating', 'contextual', 'distributed', 'emergence', 'facilitation'],
                secondary: ['stability', 'adaptivity', 'center', 'periphery', 'context', 'leading', 'following', 'facilitating', 'coordinating', 'stewarding', 'temporary', 'situational'],
                phrases: ['who leads when', 'contextual authority', 'rotating leadership', 'distributed leadership', 'situational leadership', 'expertise vs legitimacy'],
                patterns: ['leadership emergence', 'authority adaptation', 'role circulation'],
                negative: ['permanent boss', 'fixed hierarchy']
            },
            culture: {
                name: 'Cultural Dynamics',
                color: '#E81E63',
                primary: ['ritual', 'myth', 'culture', 'tradition', 'ceremony', 'symbol', 'meaning', 'values', 'norms', 'practices', 'customs', 'storytelling'],
                secondary: ['form', 'essence', 'unity', 'difference', 'past', 'future', 'sacred', 'profane', 'celebrating', 'commemorating', 'meaning-making', 'identity'],
                phrases: ['how we do things', 'origin stories', 'founding myths', 'shared values', 'organizational culture', 'cultural identity', 'ceremonial activities'],
                patterns: ['symbolic practices', 'meaning systems', 'collective identity'],
                negative: ['commercial', 'sale', 'profit-driven']
            },
            resources: {
                name: 'Resource Distribution',
                color: '#009688',
                primary: ['resources', 'power', 'wealth', 'distribution', 'circulation', 'accumulation', 'economy', 'redistribution', 'commons', 'sharing', 'hoarding'],
                secondary: ['scarcity', 'abundance', 'flow', 'stocks', 'equality', 'concentration', 'redistributing', 'circulating', 'accumulating', 'allocation', 'investment'],
                phrases: ['who has what', 'wealth gaps', 'resource inequality', 'flow vs stockpiling', 'shared resources', 'economic justice', 'resource allocation'],
                patterns: ['distribution patterns', 'accumulation dynamics', 'commons management'],
                negative: ['personal finance', 'individual wealth']
            },
            care: {
                name: 'Care Systems',
                color: '#8BC34A',
                primary: ['care', 'sustainability', 'resilience', 'fragility', 'protection', 'support', 'welfare', 'healthcare', 'ecosystem', 'planetary', 'boundaries', 'infrastructure'],
                secondary: ['individual', 'collective', 'local', 'global', 'containment', 'connection', 'caring', 'protecting', 'maintaining', 'sustaining', 'supporting', 'wellbeing'],
                phrases: ['long-term thinking', 'collective wellbeing', 'planetary scale', 'vulnerability protection', 'systemic care', 'infrastructure maintenance', 'ecosystem health'],
                patterns: ['scale of care', 'temporal horizons', 'system maintenance'],
                negative: ['individual gain', 'short-term profit']
            }
        };
        
        // State
        let allArticles = [];
        let pendingArticles = [];  // New articles waiting to be displayed
        let filteredArticles = [];
        let feedSources = [];
        let feedSourcesMap = {};  // Map source name to source object with ID
        let debugMode = false;
        let isLoading = false;
        let isFaucetOn = false;  // Content faucet state
        let activeThemeFilter = 'all';
        let themeCounts = {};
        let cachedUrls = new Set();
        let lastSyncTime = null;
        let abortController = null;  // For cancelling fetch operations
        
        // Cache statistics
        let cacheStats = {
            fromCache: 0,
            fromRSS: 0,
            new: 0,
            filtered: 0
        };
        
        // Pagination state
        let currentPage = 1;
        let pageSize = 25;
        let totalPages = 1;
        
        // Toggle theme legend
        function toggleThemeLegend() {
            const legend = document.getElementById('themeLegend');
            const btn = document.querySelector('.theme-help-btn');
            
            legend.classList.toggle('active');
            
            if (legend.classList.contains('active')) {
                btn.textContent = 'Hide Guide';
            } else {
                btn.textContent = 'Show Guide';
            }
        }
        
        // Toggle content faucet
        function toggleContentFaucet() {
            isFaucetOn = !isFaucetOn;
            const toggle = document.getElementById('faucetToggle');
            const state = document.getElementById('faucetState');
            const status = document.getElementById('faucetStatus');
            
            if (isFaucetOn) {
                toggle.classList.add('active');
                state.textContent = 'ON';
                status.textContent = 'New Content Stream - Active';
                document.getElementById('faucetInfo').textContent = 'New articles will appear automatically';
                
                // Start adding pending articles
                if (pendingArticles.length > 0) {
                    addPendingArticlesGradually();
                }
            } else {
                toggle.classList.remove('active');
                state.textContent = 'OFF';
                status.textContent = 'New Content Stream - Paused';
                document.getElementById('faucetInfo').textContent = `Click to turn on/off new articles`;
            }
        }
        
        // Add pending articles gradually when faucet is on
        function addPendingArticlesGradually() {
            if (!isFaucetOn || pendingArticles.length === 0) {
                document.getElementById('newContentIndicator').classList.remove('active');
                updatePendingCount();
                return;
            }
            
            // Add one article at a time
            const article = pendingArticles.shift();
            article.isNew = true;  // Mark as new for visual effect
            
            // Add to all articles
            allArticles.unshift(article);  // Add to beginning
            allArticles.sort((a, b) => {
                if (!a.date) return 1;
                if (!b.date) return -1;
                return b.date - a.date;
            });
            
            // Update display
            updateThemeCounts();
            filterArticles();
            updatePendingCount();
            
            // Continue adding if more pending
            if (pendingArticles.length > 0) {
                setTimeout(() => addPendingArticlesGradually(), 800);  // Stagger additions
            } else {
                document.getElementById('newContentIndicator').classList.remove('active');
            }
        }
        
        // Update pending count display
        function updatePendingCount() {
            document.getElementById('pendingCount').textContent = `${pendingArticles.length} pending`;
            document.getElementById('newContentCount').textContent = pendingArticles.length;
            
            if (pendingArticles.length > 0 && !isFaucetOn) {
                document.getElementById('newContentIndicator').classList.add('active');
            } else {
                document.getElementById('newContentIndicator').classList.remove('active');
            }
        }
        
        // Show new content (when clicking indicator)
        function showNewContent() {
            if (!isFaucetOn) {
                toggleContentFaucet();
            }
        }
        
        // Calculate theme relevance for an article
        function calculateThemeRelevance(article) {
            const text = `${article.title} ${article.description}`.toLowerCase();
            const titleText = article.title.toLowerCase();
            const scores = {};
            
            for (const [themeKey, theme] of Object.entries(THEMES)) {
                let score = 0;
                
                // Check primary keywords (3x weight in title, 1x in description)
                theme.primary.forEach(keyword => {
                    const keywordLower = keyword.toLowerCase();
                    if (titleText.includes(keywordLower)) score += 3;
                    if (text.includes(keywordLower)) score += 1;
                });
                
                // Check secondary keywords (1.5x weight in title, 0.5x in description)
                theme.secondary.forEach(keyword => {
                    const keywordLower = keyword.toLowerCase();
                    if (titleText.includes(keywordLower)) score += 1.5;
                    if (text.includes(keywordLower)) score += 0.5;
                });
                
                // Check phrases (2x weight)
                theme.phrases.forEach(phrase => {
                    const phraseLower = phrase.toLowerCase();
                    if (text.includes(phraseLower)) score += 2;
                });
                
                // Apply negative keywords (reduce score)
                if (theme.negative) {
                    theme.negative.forEach(keyword => {
                        const keywordLower = keyword.toLowerCase();
                        if (text.includes(keywordLower)) score -= 2;
                    });
                }
                
                // Source-based hints
                if (article.source_name) {
                    const sourceLower = article.source_name.toLowerCase();
                    if (themeKey === 'care' && sourceLower.includes('environment')) score += 2;
                    if (themeKey === 'governance' && (sourceLower.includes('council') || sourceLower.includes('government'))) score += 2;
                    if (themeKey === 'transparency' && sourceLower.includes('news')) score += 0.5;
                }
                
                scores[themeKey] = Math.max(0, score);
            }
            
            // Determine primary and secondary themes
            const sortedThemes = Object.entries(scores)
                .filter(([_, score]) => score > 1)
                .sort((a, b) => b[1] - a[1]);
            
            const themes = {
                primary: sortedThemes[0] ? sortedThemes[0][0] : null,
                secondary: sortedThemes.slice(1, 3).map(([key]) => key),
                scores: scores
            };
            
            return themes;
        }
        
        // Load cached content first
        async function loadCachedContent() {
            const timeWindow = parseInt(document.getElementById('timeWindow').value) || 48;
            const cutoffDate = new Date(Date.now() - (timeWindow * 60 * 60 * 1000));
            
            const params = new URLSearchParams({
                published_after: cutoffDate.toISOString()
            });
            
            try {
                updateSyncStatus('syncing', 'Loading cached articles...');
                const response = await fetch(`${CONTENT_API}?${params}`);
                
                if (!response.ok) throw new Error('Failed to load cache');
                
                const cachedArticles = await response.json();
                
                // Process cached articles
                cachedArticles.forEach(article => {
                    cachedUrls.add(article.url);
                    
                    article.fromCache = true;
                    article.link = article.url;
                    
                    if (article.published_at) {
                        article.date = new Date(article.published_at);
                    }
                    
                    // Restore themes from cache
                    if (article.category && article.category.length > 0) {
                        article.themes = {
                            primary: article.category[0],
                            secondary: article.category.slice(1, 3),
                            scores: {}
                        };
                    } else {
                        article.themes = calculateThemeRelevance(article);
                    }
                });
                
                // Filter and sort
                const themedArticles = cachedArticles.filter(article => 
                    article.themes && article.themes.primary
                );
                
                themedArticles.sort((a, b) => {
                    if (!a.date) return 1;
                    if (!b.date) return -1;
                    return b.date - a.date;
                });
                
                cacheStats.fromCache = themedArticles.length;
                allArticles = themedArticles;
                
                // Update display
                updateThemeCounts();
                filterArticles();
                updateCacheStats();
                updateSyncStatus('success', `Loaded ${themedArticles.length} cached articles`);
                
                // Enable RSS fetch button
                document.getElementById('fetchRSSBtn').disabled = false;
                
            } catch (error) {
                console.error('Cache load error:', error);
                updateSyncStatus('error', 'Cache load failed');
                document.getElementById('fetchRSSBtn').disabled = false;
            }
        }
        
        // Stop fetching operation
        function stopFetching() {
            if (abortController) {
                abortController.abort();
                abortController = null;
            }
            isLoading = false;
            
            const fetchBtn = document.getElementById('fetchRSSBtn');
            const stopBtn = document.getElementById('stopBtn');
            const progressBar = document.getElementById('progressBar');
            
            fetchBtn.disabled = false;
            stopBtn.style.display = 'none';
            progressBar.style.display = 'none';
            
            updateSyncStatus('error', 'Fetch cancelled by user');
        }
        
        // Start RSS fetch with parallel processing
        async function startRSSFetch() {
            if (isLoading) return;
            
            isLoading = true;
            abortController = new AbortController();
            
            const fetchBtn = document.getElementById('fetchRSSBtn');
            const stopBtn = document.getElementById('stopBtn');
            const progressBar = document.getElementById('progressBar');
            
            fetchBtn.disabled = true;
            stopBtn.style.display = 'inline-block';
            progressBar.style.display = 'block';
            
            updateProgress(10, 'Loading RSS sources...');
            
            try {
                // Load RSS sources and create ID map
                const sources = await loadSources();
                
                if (sources.length === 0) {
                    isLoading = false;
                    fetchBtn.disabled = false;
                    stopBtn.style.display = 'none';
                    progressBar.style.display = 'none';
                    updateSyncStatus('error', 'No feed sources found');
                    return;
                }
                
                // Create map of source names to IDs
                sources.forEach(source => {
                    feedSourcesMap[source.title || source.name] = source.id;
                });
                
                updateProgress(20, `Fetching from ${sources.length} sources in parallel...`);
                
                // Reset pending articles
                pendingArticles = [];
                let processedCount = 0;
                let totalNewArticles = 0;
                
                // Set all sources to loading state
                sources.forEach(source => {
                    updateSourceStatus(source.name || source.title, 'loading');
                });
                
                // Define number of concurrent fetches (adjust based on performance needs)
                const CONCURRENT_FETCHES = 5;
                
                // Process sources in batches for controlled parallelism
                async function processBatch(batch) {
                    const batchPromises = batch.map(async (source) => {
                        // Check if aborted
                        if (abortController.signal.aborted) {
                            throw new Error('Fetch cancelled');
                        }
                        
                        try {
                            const articles = await fetchFeed(source);
                            const sourceNewArticles = [];
                            
                            // Process articles for this source
                            const cacheCheckPromises = articles.map(async (article) => {
                                if (abortController.signal.aborted) return null;
                                
                                const inCache = await checkUrlInCache(article.url);
                                
                                if (!inCache) {
                                    // Calculate themes
                                    article.themes = calculateThemeRelevance(article);
                                    
                                    // Set the RSS feed ID
                                    article.rss_feed_id = source.id;
                                    
                                    // Only keep articles WITH themes
                                    if (article.themes && article.themes.primary) {
                                        article.fromCache = false;
                                        return article;
                                    } else {
                                        cacheStats.filtered++;
                                        return null;
                                    }
                                }
                                return null;
                            });
                            
                            const checkedArticles = await Promise.all(cacheCheckPromises);
                            const validArticles = checkedArticles.filter(a => a !== null);
                            
                            if (validArticles.length > 0) {
                                sourceNewArticles.push(...validArticles);
                                cacheStats.fromRSS += validArticles.length;
                                
                                // Post to cache in background (don't await)
                                postToCache(validArticles).then(() => {
                                    updateCacheStats();
                                }).catch(err => console.error('Cache post error:', err));
                            }
                            
                            updateSourceStatus(source.name || source.title, articles.length > 0 ? 'active' : 'error');
                            
                            return sourceNewArticles;
                            
                        } catch (error) {
                            console.error(`Error processing ${source.name || source.title}:`, error);
                            updateSourceStatus(source.name || source.title, 'error');
                            return [];
                        } finally {
                            processedCount++;
                            const progress = 20 + (processedCount / sources.length) * 70;
                            updateProgress(progress, `Processed ${processedCount}/${sources.length} sources...`);
                        }
                    });
                    
                    const results = await Promise.all(batchPromises);
                    return results.flat();
                }
                
                // Split sources into batches
                const batches = [];
                for (let i = 0; i < sources.length; i += CONCURRENT_FETCHES) {
                    batches.push(sources.slice(i, i + CONCURRENT_FETCHES));
                }
                
                // Process all batches
                const startTime = Date.now();
                const allNewArticles = [];
                
                for (const batch of batches) {
                    if (!isLoading || abortController.signal.aborted) break;
                    
                    const batchArticles = await processBatch(batch);
                    allNewArticles.push(...batchArticles);
                    totalNewArticles = allNewArticles.length;
                    
                    // Update pending count in real-time
                    pendingArticles = [...allNewArticles];
                    updatePendingCount();
                }
                
                const fetchTime = ((Date.now() - startTime) / 1000).toFixed(1);
                updateProgress(95, `Finalizing... (fetched in ${fetchTime}s)`);
                
                // Sort pending articles by date
                pendingArticles.sort((a, b) => {
                    if (!a.date) return 1;
                    if (!b.date) return -1;
                    return b.date - a.date;
                });
                
                updatePendingCount();
                updateProgress(100, `RSS fetch complete! (${fetchTime}s)`);
                
                setTimeout(() => {
                    progressBar.style.display = 'none';
                    stopBtn.style.display = 'none';
                    updateSyncStatus('success', `Found ${pendingArticles.length} new articles in ${fetchTime}s`);
                }, 1000);
                
                // Auto-start faucet if articles found
                if (pendingArticles.length > 0 && !isFaucetOn) {
                    setTimeout(() => {
                        if (confirm(`Found ${pendingArticles.length} new articles. Turn on content stream?`)) {
                            toggleContentFaucet();
                        }
                    }, 1500);
                }
                
            } catch (error) {
                if (error.message === 'Fetch cancelled') {
                    console.log('Fetch operation cancelled');
                } else {
                    console.error('Fetch error:', error);
                    updateSyncStatus('error', 'Fetch failed: ' + error.message);
                }
            } finally {
                isLoading = false;
                fetchBtn.disabled = false;
                stopBtn.style.display = 'none';
                abortController = null;
            }
        }
        
        // Load RSS sources
        async function loadSources() {
            try {
                const response = await fetch(SOURCES_API);
                if (!response.ok) throw new Error('Failed to load sources');
                
                const data = await response.json();
                feedSources = data;
                updateSourcesDisplay();
                return data;
            } catch (error) {
                console.error('Error loading sources:', error);
                showError('Failed to load feed sources');
                return [];
            }
        }
        
        // Parse RSS feed
        function parseRSSFeed(xmlText, sourceName, sourceId) {
            const parser = new DOMParser();
            const xml = parser.parseFromString(xmlText, 'text/xml');
            const articles = [];
            
            if (xml.querySelector('parsererror')) {
                console.error('XML parse error for', sourceName);
                return articles;
            }
            
            let items = xml.querySelectorAll('item');
            if (items.length === 0) {
                items = xml.querySelectorAll('entry');
            }
            
            items.forEach(item => {
                const title = item.querySelector('title')?.textContent || '';
                const link = item.querySelector('link')?.textContent || 
                           item.querySelector('link')?.getAttribute('href') || '';
                const description = item.querySelector('description')?.textContent || 
                                  item.querySelector('summary')?.textContent || 
                                  item.querySelector('content\\:encoded')?.textContent || '';
                const pubDate = item.querySelector('pubDate')?.textContent || 
                              item.querySelector('published')?.textContent || 
                              item.querySelector('updated')?.textContent || '';
                const author = item.querySelector('author')?.textContent || 
                             item.querySelector('dc\\:creator')?.textContent || 
                             item.querySelector('creator')?.textContent || '';
                
                // Extract image URL
                let imageUrl = '';
                const mediaContent = item.querySelector('media\\:content, content');
                if (mediaContent && mediaContent.getAttribute('url')) {
                    imageUrl = mediaContent.getAttribute('url');
                }
                
                if (!imageUrl) {
                    const enclosure = item.querySelector('enclosure');
                    if (enclosure && enclosure.getAttribute('type')?.startsWith('image')) {
                        imageUrl = enclosure.getAttribute('url');
                    }
                }
                
                if (!imageUrl) {
                    const thumbnail = item.querySelector('media\\:thumbnail, thumbnail');
                    if (thumbnail) {
                        imageUrl = thumbnail.getAttribute('url');
                    }
                }
                
                if (title || description) {
                    const article = {
                        title: cleanText(title || 'Untitled'),
                        link: link || '#',
                        url: link || '#',
                        description: cleanHTML(description || ''),
                        date: parseDate(pubDate),
                        published_at: parseDate(pubDate),
                        author: cleanText(author),
                        source: sourceName,
                        source_name: sourceName,
                        image_url: imageUrl,
                        rss_feed_id: sourceId,  // Add source ID
                        themes: null
                    };
                    
                    articles.push(article);
                }
            });
            
            return articles;
        }
        
        // Fetch RSS feed
        async function fetchFeed(source) {
            const url = source.url || source.link;
            const name = source.name || source.title || 'Unknown';
            const sourceId = source.id;
            
            if (!url) return [];
            
            try {
                const proxyUrl = CORS_PROXY + encodeURIComponent(url);
                const response = await fetch(proxyUrl);
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const text = await response.text();
                const articles = parseRSSFeed(text, name, sourceId);
                
                return articles;
            } catch (error) {
                console.error(`Error fetching ${name}:`, error);
                return [];
            }
        }
        
        // Check if URL exists in cache (with request throttling)
        async function checkUrlInCache(url) {
            if (cachedUrls.has(url)) return true;
            
            // Skip individual API checks during bulk operations
            // Rely on local cache set for better performance
            return false;
        }
        
        // Batch check URLs in cache (more efficient for multiple URLs)
        async function batchCheckUrlsInCache(urls) {
            const uncachedUrls = urls.filter(url => !cachedUrls.has(url));
            
            if (uncachedUrls.length === 0) {
                return new Map(urls.map(url => [url, true]));
            }
            
            // For now, assume uncached (could implement batch endpoint if available)
            const results = new Map();
            urls.forEach(url => {
                results.set(url, cachedUrls.has(url));
            });
            
            return results;
        }
        
        // Post new articles to Xano with RSS feed ID (parallel batch processing)
        async function postToCache(articles) {
            if (articles.length === 0) return;
            
            const themedArticles = articles.filter(a => a.themes && a.themes.primary);
            
            if (themedArticles.length === 0) {
                console.log('No themed articles to post to cache');
                return;
            }
            
            console.log(`Posting ${themedArticles.length} themed articles to Xano...`);
            
            let successCount = 0;
            let errorCount = 0;
            
            // Process in parallel batches for better performance
            const PARALLEL_POSTS = 5;
            const postPromises = [];
            
            for (let i = 0; i < themedArticles.length; i += PARALLEL_POSTS) {
                const batch = themedArticles.slice(i, i + PARALLEL_POSTS);
                
                const batchPromise = Promise.all(batch.map(async (article) => {
                    try {
                        const xanoArticle = {
                            url: article.link || article.url || '',
                            title: article.title || 'Untitled',
                            description: article.description || '',
                            published_at: article.date ? article.date.toISOString() : new Date().toISOString(),
                            source_name: article.source_name || article.source || 'Unknown',
                            author: article.author || '',
                            image_url: article.image_url || '',
                            rss_feed: article.rss_feed_id || null,  // Include RSS feed ID
                            category: [],
                            keywords: []
                        };
                        
                        // Add themes as categories
                        if (article.themes && article.themes.primary) {
                            xanoArticle.category.push(article.themes.primary);
                            
                            if (article.themes.secondary && article.themes.secondary.length > 0) {
                                xanoArticle.category = xanoArticle.category.concat(article.themes.secondary);
                            }
                        }
                        
                        // Extract keywords
                        const combinedText = `${article.title} ${article.description}`.toLowerCase();
                        const stopWords = new Set(['the', 'is', 'at', 'which', 'on', 'and', 'a', 'an', 'as', 'are', 'was', 'been', 'be', 'have', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might', 'must', 'can', 'shall', 'to', 'of', 'in', 'for', 'with', 'by', 'from', 'up', 'about', 'into', 'through', 'during', 'before', 'after', 'above', 'below', 'between', 'under', 'again', 'further', 'then', 'once']);
                        
                        const words = combinedText
                            .replace(/[^\w\s]/g, ' ')
                            .split(/\s+/)
                            .filter(word => word.length > 4 && !stopWords.has(word))
                            .slice(0, 15);
                        
                        xanoArticle.keywords = [...new Set(words)];
                        
                        const response = await fetch(CONTENT_API, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(xanoArticle)
                        });
                        
                        if (response.ok) {
                            cachedUrls.add(xanoArticle.url);
                            cacheStats.new++;
                            successCount++;
                            return { success: true };
                        } else {
                            const errorText = await response.text();
                            console.error(`Failed to post article: ${response.status}`, errorText);
                            errorCount++;
                            return { success: false, error: errorText };
                        }
                        
                    } catch (error) {
                        console.error('Failed to cache article:', error);
                        errorCount++;
                        return { success: false, error: error.message };
                    }
                }));
                
                postPromises.push(batchPromise);
                
                // Small delay between batches to avoid overwhelming the server
                if (i + PARALLEL_POSTS < themedArticles.length) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            // Wait for all posts to complete
            await Promise.all(postPromises);
            
            console.log(`Posted ${successCount} articles successfully, ${errorCount} errors`);
        }
        
        // Force refresh
        async function forceRefresh() {
            if (confirm('This will clear the local cache and reload everything. Continue?')) {
                cachedUrls.clear();
                allArticles = [];
                pendingArticles = [];
                cacheStats = { fromCache: 0, fromRSS: 0, new: 0, filtered: 0 };
                
                await loadCachedContent();
                await startRSSFetch();
            }
        }
        
        // Update sync status
        function updateSyncStatus(status, message) {
            const statusEl = document.getElementById('syncStatus');
            statusEl.className = `sync-status ${status}`;
            statusEl.innerHTML = `<span>${message}</span>`;
            
            if (status === 'success' || status === 'error') {
                setTimeout(() => {
                    statusEl.className = 'sync-status';
                    statusEl.innerHTML = '<span>Ready</span>';
                }, 3000);
            }
        }
        
        // Update cache statistics display
        function updateCacheStats() {
            document.getElementById('cachedCount').textContent = cacheStats.fromCache;
            document.getElementById('newCount').textContent = cacheStats.new;
            document.getElementById('rssCount').textContent = cacheStats.fromRSS;
            document.getElementById('filteredCount').textContent = cacheStats.filtered;
        }
        
        // Update last sync time
        function updateLastSyncTime() {
            const el = document.getElementById('lastSync');
            if (lastSyncTime) {
                el.textContent = lastSyncTime.toLocaleTimeString();
            } else {
                el.textContent = 'Never';
            }
        }
        
        // Clean text content
        function cleanText(text) {
            if (!text) return '';
            return text.replace(/<[^>]*>/g, '').trim();
        }
        
        // Clean HTML content
        function cleanHTML(html) {
            if (!html) return '';
            html = html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
            html = html.replace(/<style\b[^<]*(?:(?!<\/style>)<[^<]*)*<\/style>/gi, '');
            html = html.replace(/<[^>]*>/g, ' ');
            html = html.replace(/\s+/g, ' ').trim();
            return html;
        }
        
        // Parse date strings
        function parseDate(dateStr) {
            if (!dateStr) return null;
            const date = new Date(dateStr);
            return isNaN(date.getTime()) ? null : date;
        }
        
        // Filter by theme
        function filterByTheme(theme) {
            activeThemeFilter = theme;
            
            document.querySelectorAll('.theme-filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const activeBtn = document.querySelector(`.theme-filter-btn.theme-${theme}`);
            if (activeBtn) activeBtn.classList.add('active');
            
            if (theme === 'all') {
                filteredArticles = [];
                currentPage = 1;
                displayArticles(allArticles);
            } else {
                filteredArticles = allArticles.filter(article => {
                    return article.themes && 
                           (article.themes.primary === theme || 
                            (article.themes.secondary && article.themes.secondary.includes(theme)));
                });
                currentPage = 1;
                displayArticles(filteredArticles);
            }
            
            updateStats();
        }
        
        // Update theme counts
        function updateThemeCounts() {
            themeCounts = {
                all: allArticles.length,
                governance: 0,
                transparency: 0,
                decisions: 0,
                leadership: 0,
                culture: 0,
                resources: 0,
                care: 0
            };
            
            allArticles.forEach(article => {
                if (article.themes) {
                    if (article.themes.primary) {
                        themeCounts[article.themes.primary]++;
                    }
                    if (article.themes.secondary) {
                        article.themes.secondary.forEach(theme => {
                            themeCounts[theme]++;
                        });
                    }
                }
            });
            
            Object.entries(themeCounts).forEach(([theme, count]) => {
                const btn = document.querySelector(`.theme-filter-btn.theme-${theme} .count`);
                if (btn) btn.textContent = count;
            });
            
            updateThemeAnalytics();
        }
        
        // Update theme analytics
        function updateThemeAnalytics() {
            const container = document.getElementById('themeAnalytics');
            let html = '';
            
            Object.entries(THEMES).forEach(([key, theme]) => {
                const count = themeCounts[key] || 0;
                const percentage = allArticles.length > 0 ? 
                    Math.round((count / allArticles.length) * 100) : 0;
                
                html += `
                    <div class="theme-stat">
                        <span class="theme-dot" style="background: ${theme.color}"></span>
                        ${theme.name}: ${count} (${percentage}%)
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        // Clear articles
        function clearArticles() {
            allArticles = [];
            pendingArticles = [];
            filteredArticles = [];
            currentPage = 1;
            activeThemeFilter = 'all';
            cacheStats = { fromCache: 0, fromRSS: 0, new: 0, filtered: 0 };
            isFaucetOn = false;
            
            displayArticles([]);
            updateThemeCounts();
            updateCacheStats();
            updatePendingCount();
            updateStats('Articles cleared. Cache preserved.');
            
            // Reset faucet
            document.getElementById('faucetToggle').classList.remove('active');
            document.getElementById('faucetState').textContent = 'OFF';
            document.getElementById('faucetStatus').textContent = 'New Content Stream';
            
            feedSources.forEach(source => {
                updateSourceStatus(source.name || source.title, '');
            });
            
            document.querySelectorAll('.theme-filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector('.theme-filter-btn.theme-all').classList.add('active');
        }
        
        // Update progress bar
        function updateProgress(percent, text) {
            const fill = document.getElementById('progressFill');
            fill.style.width = percent + '%';
            fill.textContent = text || percent + '%';
        }
        
        // Display articles with pagination
        function displayArticles(articles) {
            const container = document.getElementById('articlesContainer');
            
            if (!articles || articles.length === 0) {
                container.innerHTML = '<div class="error">No articles found</div>';
                document.getElementById('topPagination').style.display = 'none';
                document.getElementById('bottomPagination').style.display = 'none';
                return;
            }
            
            totalPages = Math.ceil(articles.length / pageSize);
            currentPage = Math.min(currentPage, totalPages);
            
            const startIndex = (currentPage - 1) * pageSize;
            const endIndex = Math.min(startIndex + pageSize, articles.length);
            const pageArticles = articles.slice(startIndex, endIndex);
            
            updatePaginationControls();
            
            let html = '';
            pageArticles.forEach(article => {
                const articleClass = article.isNew ? 'article new-article' : 'article';
                html += `<div class="${articleClass}">`;
                
                // Show image if available
                if (article.image_url) {
                    html += '<div style="float: right; margin: 0 0 10px 15px; max-width: 200px;">';
                    html += `<img src="${escapeHtml(article.image_url)}" alt="${escapeHtml(article.title)}" style="width: 100%; height: auto; border-radius: 4px;">`;
                    html += '</div>';
                }
                
                // Header with title and theme badges
                html += '<div class="article-header">';
                html += '<div class="article-title">';
                html += `<a href="${escapeHtml(article.link || article.url)}" target="_blank" rel="noopener">`;
                html += escapeHtml(article.title);
                html += '</a>';
                
                // Show status badge
                if (article.fromCache) {
                    html += '<span class="article-cached">cached</span>';
                } else if (article.isNew) {
                    html += '<span class="article-new">NEW</span>';
                }
                
                html += '</div>';
                
                // Theme badges with confidence indicators
                if (article.themes && article.themes.primary) {
                    html += '<div class="article-themes">';
                    
                    if (article.themes.primary) {
                        const theme = THEMES[article.themes.primary];
                        if (theme) {
                            const confidence = article.themes.confidence || 'low';
                            const confidenceClass = confidence === 'low' ? 'low-confidence' : '';
                            html += `<span class="theme-badge primary ${confidenceClass}" style="background: ${theme.color}" title="${theme.name} (${confidence} confidence)">`;
                            html += theme.name;
                            if (debugMode) {
                                html += `<span class="confidence-indicator confidence-${confidence}"></span>`;
                            }
                            html += '</span>';
                        }
                    }
                    
                    if (article.themes.secondary) {
                        article.themes.secondary.forEach(themeKey => {
                            const theme = THEMES[themeKey];
                            if (theme) {
                                html += `<span class="theme-badge secondary" style="background: ${theme.color}" title="${theme.name} (secondary)">${theme.name}</span>`;
                            }
                        });
                    }
                    
                    html += '</div>';
                }
                
                html += '</div>';
                
                // Meta information
                html += '<div class="article-meta">';
                html += `<span class="article-source">${escapeHtml(article.source_name || article.source)}</span>`;
                if (article.date) {
                    html += ` • ${article.date.toLocaleString()}`;
                }
                if (article.author) {
                    html += ` • By ${escapeHtml(article.author)}`;
                }
                html += '</div>';
                
                // Description
                if (article.description) {
                    html += '<div class="article-description">';
                    const desc = article.description.substring(0, 300);
                    html += escapeHtml(desc);
                    if (article.description.length > 300) html += '...';
                    html += '</div>';
                }
                
                html += '<div style="clear: both;"></div>';
                html += '</div>';
                
                // Remove new flag after display
                if (article.isNew) {
                    setTimeout(() => {
                        article.isNew = false;
                    }, 3000);
                }
            });
            
            container.innerHTML = html;
            
            const showPagination = articles.length > pageSize;
            document.getElementById('topPagination').style.display = showPagination ? 'flex' : 'none';
            document.getElementById('bottomPagination').style.display = showPagination ? 'flex' : 'none';
        }
        
        // Update pagination controls
        function updatePaginationControls() {
            document.getElementById('currentPageTop').textContent = currentPage;
            document.getElementById('totalPagesTop').textContent = totalPages;
            document.getElementById('currentPageBottom').textContent = currentPage;
            document.getElementById('totalPagesBottom').textContent = totalPages;
        }
        
        // Pagination functions
        function goToPage(page) {
            currentPage = Math.max(1, Math.min(page, totalPages));
            displayArticles(filteredArticles.length > 0 || activeThemeFilter !== 'all' ? filteredArticles : allArticles);
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        function nextPage() {
            goToPage(currentPage + 1);
        }
        
        function previousPage() {
            goToPage(currentPage - 1);
        }
        
        function changePageSize(size) {
            pageSize = parseInt(size);
            currentPage = 1;
            document.getElementById('pageSizeTop').value = size;
            document.getElementById('pageSizeBottom').value = size;
            displayArticles(filteredArticles.length > 0 || activeThemeFilter !== 'all' ? filteredArticles : allArticles);
        }
        
        // Filter articles by search term
        function filterArticles() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            
            let baseArticles = activeThemeFilter === 'all' ? allArticles : 
                allArticles.filter(article => {
                    return article.themes && 
                           (article.themes.primary === activeThemeFilter || 
                            article.themes.secondary.includes(activeThemeFilter));
                });
            
            if (!searchTerm) {
                filteredArticles = activeThemeFilter === 'all' ? [] : baseArticles;
                displayArticles(baseArticles);
                updateStats();
                return;
            }
            
            filteredArticles = baseArticles.filter(article => {
                return article.title.toLowerCase().includes(searchTerm) ||
                       article.description.toLowerCase().includes(searchTerm) ||
                       (article.source_name || article.source).toLowerCase().includes(searchTerm);
            });
            
            currentPage = 1;
            displayArticles(filteredArticles);
            updateStats();
        }
        
        // Update sources display
        function updateSourcesDisplay() {
            const container = document.getElementById('feedSources');
            let html = '<strong>Feed Sources:</strong> ';
            
            feedSources.forEach(source => {
                const name = source.name || source.title || 'Unknown';
                html += `<span class="source-badge" id="source-${name.replace(/\s+/g, '-')}">${escapeHtml(name)}</span>`;
            });
            
            container.innerHTML = html;
        }
        
        // Update source status
        function updateSourceStatus(name, status) {
            const badge = document.getElementById(`source-${name.replace(/\s+/g, '-')}`);
            if (badge) {
                badge.className = `source-badge ${status}`;
            }
        }
        
        // Update stats
        function updateStats(customMessage) {
            const articlesToShow = filteredArticles.length > 0 || activeThemeFilter !== 'all' ? 
                filteredArticles : allArticles;
            
            let message = customMessage || `Showing ${articlesToShow.length} articles`;
            
            if (activeThemeFilter !== 'all') {
                const themeName = THEMES[activeThemeFilter]?.name || activeThemeFilter;
                message += ` (filtered by ${themeName})`;
            }
            
            if (filteredArticles.length > 0 && document.getElementById('searchInput').value) {
                message += ' (search active)';
            }
            
            if (cacheStats.filtered > 0) {
                message += ` <em style="font-size: 12px; color: #999;">(${cacheStats.filtered} non-civic articles filtered out)</em>`;
            }
            
            document.getElementById('stats').innerHTML = message + 
                '<div class="theme-analytics" id="themeAnalytics"></div>';
            
            updateThemeAnalytics();
        }
        
        // Show error
        function showError(message) {
            const container = document.getElementById('articlesContainer');
            container.innerHTML = `<div class="error">${escapeHtml(message)}</div>`;
        }
        
        // Toggle debug panel
        function toggleDebug() {
            debugMode = !debugMode;
            const panel = document.getElementById('debugPanel');
            panel.classList.toggle('active');
            
            if (debugMode) {
                updateDebug();
            }
        }
        
        // Update debug info
        function updateDebug() {
            const panel = document.getElementById('debugPanel');
            let debug = 'Debug Information\n';
            debug += '=================\n\n';
            debug += `Total Sources: ${feedSources.length}\n`;
            debug += `Total Articles: ${allArticles.length}\n`;
            debug += `Pending Articles: ${pendingArticles.length}\n`;
            debug += `Filtered Articles: ${filteredArticles.length}\n`;
            debug += `Active Theme Filter: ${activeThemeFilter}\n`;
            debug += `Cached URLs: ${cachedUrls.size}\n`;
            debug += `Current Page: ${currentPage}/${totalPages}\n`;
            debug += `Page Size: ${pageSize}\n`;
            debug += `Faucet State: ${isFaucetOn ? 'ON' : 'OFF'}\n`;
            debug += `Loading State: ${isLoading ? 'ACTIVE' : 'IDLE'}\n`;
            debug += `Parallel Fetch: 5 concurrent threads\n\n`;
            
            debug += 'Cache Statistics:\n';
            debug += `  From Cache: ${cacheStats.fromCache}\n`;
            debug += `  From RSS: ${cacheStats.fromRSS}\n`;
            debug += `  New Cached: ${cacheStats.new}\n`;
            debug += `  Filtered Out: ${cacheStats.filtered}\n\n`;
            
            debug += 'Feed Source IDs:\n';
            Object.entries(feedSourcesMap).forEach(([name, id]) => {
                debug += `  ${name}: ${id}\n`;
            });
            
            debug += '\nTheme Distribution:\n';
            Object.entries(themeCounts).forEach(([theme, count]) => {
                if (theme !== 'all') {
                    const percentage = allArticles.length > 0 ? 
                        Math.round((count / allArticles.length) * 100) : 0;
                    debug += `  ${theme}: ${count} articles (${percentage}%)\n`;
                }
            });
            
            debug += '\nArticles by Source:\n';
            const sourceCounts = {};
            allArticles.forEach(article => {
                const source = article.source_name || article.source;
                sourceCounts[source] = (sourceCounts[source] || 0) + 1;
            });
            
            Object.entries(sourceCounts)
                .sort((a, b) => b[1] - a[1])
                .forEach(([source, count]) => {
                    debug += `  ${source}: ${count} articles\n`;
                });
            
            panel.textContent = debug;
        }
        
        // Escape HTML
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = String(text);
            return div.innerHTML;
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            updateStats('Ready to load. Click "Load Cached" to begin.');
            updateCacheStats();
            updateLastSyncTime();
            updatePendingCount();
            
            // Load preferences
            const savedTimeWindow = localStorage.getItem(CACHE_CONFIG.localCacheKey + '_timeWindow');
            if (savedTimeWindow) {
                document.getElementById('timeWindow').value = savedTimeWindow;
            }
            
            // Save preferences on change
            document.getElementById('timeWindow').addEventListener('change', (e) => {
                localStorage.setItem(CACHE_CONFIG.localCacheKey + '_timeWindow', e.target.value);
            });
            
            // Disable RSS fetch button initially
            document.getElementById('fetchRSSBtn').disabled = true;
        });
    </script>
</body>
</html>
